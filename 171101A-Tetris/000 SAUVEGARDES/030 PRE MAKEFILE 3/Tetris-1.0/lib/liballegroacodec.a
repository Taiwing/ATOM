!<arch>
acodec.c/       0           0     0     644     2175      `
#include "allegro5/allegro_acodec.h"
#include "allegro5/allegro_audio.h"
#include "allegro5/internal/aintern_acodec_cfg.h"
#include "acodec.h"


/* Function: al_get_allegro_acodec_version
 */
uint32_t al_get_allegro_acodec_version(void)
{
   return ALLEGRO_VERSION_INT;
}


/* Function: al_init_acodec_addon
 */
bool al_init_acodec_addon(void)
{
   bool ret = true;

   ret &= al_register_sample_loader(".wav", _al_load_wav);
   ret &= al_register_sample_saver(".wav", _al_save_wav);
   ret &= al_register_audio_stream_loader(".wav", _al_load_wav_audio_stream);

   ret &= al_register_sample_loader_f(".wav", _al_load_wav_f);
   ret &= al_register_sample_saver_f(".wav", _al_save_wav_f);
   ret &= al_register_audio_stream_loader_f(".wav", _al_load_wav_audio_stream_f);

#ifdef ALLEGRO_CFG_ACODEC_FLAC
   ret &= al_register_sample_loader(".flac", _al_load_flac);
   ret &= al_register_audio_stream_loader(".flac", _al_load_flac_audio_stream);
   ret &= al_register_sample_loader_f(".flac", _al_load_flac_f);
   ret &= al_register_audio_stream_loader_f(".flac", _al_load_flac_audio_stream_f);
#endif

#ifdef ALLEGRO_CFG_ACODEC_MODAUDIO
   ret &= al_register_audio_stream_loader(".xm", _al_load_xm_audio_stream);
   ret &= al_register_audio_stream_loader_f(".xm", _al_load_xm_audio_stream_f);
   ret &= al_register_audio_stream_loader(".it", _al_load_it_audio_stream);
   ret &= al_register_audio_stream_loader_f(".it", _al_load_it_audio_stream_f);
   ret &= al_register_audio_stream_loader(".mod", _al_load_mod_audio_stream);
   ret &= al_register_audio_stream_loader_f(".mod", _al_load_mod_audio_stream_f);
   ret &= al_register_audio_stream_loader(".s3m", _al_load_s3m_audio_stream);
   ret &= al_register_audio_stream_loader_f(".s3m", _al_load_s3m_audio_stream_f);
#endif

#ifdef ALLEGRO_CFG_ACODEC_VORBIS
   ret &= al_register_sample_loader(".ogg", _al_load_ogg_vorbis);
   ret &= al_register_audio_stream_loader(".ogg", _al_load_ogg_vorbis_audio_stream);
   ret &= al_register_sample_loader_f(".ogg", _al_load_ogg_vorbis_f);
   ret &= al_register_audio_stream_loader_f(".ogg", _al_load_ogg_vorbis_audio_stream_f);
#endif

   return ret;
}


/* vim: set sts=3 sw=3 et: */

flac.c/         0           0     0     644     18050     `
/*
 * Allegro FLAC reader
 * author: Ryan Dickie, (c) 2008
 * streaming support by Elias Pschernig
 */


#include "allegro5/allegro.h"
#include "allegro5/allegro_acodec.h"
#include "allegro5/allegro_audio.h"
#include "allegro5/internal/aintern.h"
#include "allegro5/internal/aintern_audio.h"
#include "allegro5/internal/aintern_system.h"
#include "acodec.h"
#include "helper.h"

#ifndef ALLEGRO_CFG_ACODEC_FLAC
   #error configuration problem, ALLEGRO_CFG_ACODEC_FLAC not set
#endif

#include <FLAC/stream_decoder.h>
#include <stdio.h>

ALLEGRO_DEBUG_CHANNEL("acodec")


typedef struct FLACFILE {
   FLAC__StreamDecoder *decoder;
   double sample_rate;
   int sample_size;
   int channels;

   /* The file buffer. */
   uint64_t buffer_pos, buffer_size;
   char *buffer;

   /* Number of samples in the complete FLAC. */
   uint64_t total_samples;

   /* Sample position one past last decoded sample. */
   uint64_t decoded_samples;

   /* Sample position one past last streamed sample. */
   uint64_t streamed_samples;

   ALLEGRO_FILE *fh;
   uint64_t loop_start, loop_end; /* in samples */
} FLACFILE;


/* dynamic loading support (Windows only currently) */
#ifdef ALLEGRO_CFG_ACODEC_FLAC_DLL
static void *flac_dll = NULL;
static bool flac_virgin = true;
#endif

static struct
{
   FLAC__StreamDecoder *(*FLAC__stream_decoder_new)(void);
   void (*FLAC__stream_decoder_delete)(FLAC__StreamDecoder *decoder);
   FLAC__StreamDecoderInitStatus (*FLAC__stream_decoder_init_stream)(
      FLAC__StreamDecoder *decoder,
      FLAC__StreamDecoderReadCallback read_callback,
      FLAC__StreamDecoderSeekCallback seek_callback,
      FLAC__StreamDecoderTellCallback tell_callback,
      FLAC__StreamDecoderLengthCallback length_callback,
      FLAC__StreamDecoderEofCallback eof_callback,
      FLAC__StreamDecoderWriteCallback write_callback,
      FLAC__StreamDecoderMetadataCallback metadata_callback,
      FLAC__StreamDecoderErrorCallback error_callback,
      void *client_data);
   FLAC__bool (*FLAC__stream_decoder_process_single)(FLAC__StreamDecoder *decoder);
   FLAC__bool (*FLAC__stream_decoder_process_until_end_of_metadata)(FLAC__StreamDecoder *decoder);
   FLAC__bool (*FLAC__stream_decoder_process_until_end_of_stream)(FLAC__StreamDecoder *decoder);
   FLAC__bool (*FLAC__stream_decoder_seek_absolute)(FLAC__StreamDecoder *decoder, FLAC__uint64 sample);
   FLAC__bool (*FLAC__stream_decoder_flush)(FLAC__StreamDecoder *decoder);
   FLAC__bool (*FLAC__stream_decoder_finish)(FLAC__StreamDecoder *decoder);
} lib;


#ifdef ALLEGRO_CFG_ACODEC_FLAC_DLL
static void shutdown_dynlib(void)
{
   if (flac_dll) {
      _al_close_library(flac_dll);
      flac_dll = NULL;
      flac_virgin = true;
   }
}
#endif


static bool init_dynlib(void)
{
#ifdef ALLEGRO_CFG_ACODEC_FLAC_DLL
   if (flac_dll) {
      return true;
   }

   if (!flac_virgin) {
      return false;
   }

   flac_virgin = false;

   flac_dll = _al_open_library(ALLEGRO_CFG_ACODEC_FLAC_DLL);
   if (!flac_dll) {
      ALLEGRO_WARN("Could not load " ALLEGRO_CFG_ACODEC_FLAC_DLL "\n");
      return false;
   }

   _al_add_exit_func(shutdown_dynlib, "shutdown_dynlib");

   #define INITSYM(x)                                                         \
      do                                                                      \
      {                                                                       \
         lib.x = _al_import_symbol(flac_dll, #x);                             \
         if (lib.x == 0) {                                                    \
            ALLEGRO_ERROR("undefined symbol in lib structure: " #x "\n");     \
            return false;                                                     \
         }                                                                    \
      } while(0)
#else
   #define INITSYM(x)   (lib.x = (x))
#endif

   memset(&lib, 0, sizeof(lib));

   INITSYM(FLAC__stream_decoder_new);
   INITSYM(FLAC__stream_decoder_delete);
   INITSYM(FLAC__stream_decoder_init_stream);
   INITSYM(FLAC__stream_decoder_process_single);
   INITSYM(FLAC__stream_decoder_process_until_end_of_metadata);
   INITSYM(FLAC__stream_decoder_process_until_end_of_stream);
   INITSYM(FLAC__stream_decoder_seek_absolute);
   INITSYM(FLAC__stream_decoder_flush);
   INITSYM(FLAC__stream_decoder_finish);

   return true;

#undef INITSYM
}


static FLAC__StreamDecoderReadStatus read_callback(const FLAC__StreamDecoder *decoder,
   FLAC__byte buffer[], size_t *bytes, void *dptr)
{
   FLACFILE *ff = (FLACFILE *)dptr;
   ALLEGRO_FILE *fh = ff->fh;
   (void)decoder;
   if (*bytes > 0) {
      *bytes = al_fread(fh, buffer, *bytes);
      if (al_ferror(fh))
         return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
      else if (*bytes == 0)
         return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;
      else
         return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
   }
   else
      return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
}


static FLAC__StreamDecoderSeekStatus seek_callback(
   const FLAC__StreamDecoder *decoder,
   FLAC__uint64 absolute_byte_offset, void *dptr)
{
   FLACFILE *ff = (FLACFILE *)dptr;
   ALLEGRO_FILE *fh = ff->fh;
   (void)decoder;

   if (!al_fseek(fh, absolute_byte_offset, ALLEGRO_SEEK_SET))
      return FLAC__STREAM_DECODER_SEEK_STATUS_ERROR;
   else
      return FLAC__STREAM_DECODER_SEEK_STATUS_OK;
}


static FLAC__StreamDecoderTellStatus tell_callback(
   const FLAC__StreamDecoder *decoder,
   FLAC__uint64 *absolute_byte_offset, void *dptr)
{
   FLACFILE *ff = (FLACFILE *)dptr;
   ALLEGRO_FILE *fh = ff->fh;
   int64_t pos = 0;
   (void)decoder;

   pos = al_ftell(fh);
   if (pos == -1)
      return FLAC__STREAM_DECODER_TELL_STATUS_ERROR;

   *absolute_byte_offset = (FLAC__uint64)pos;
   return FLAC__STREAM_DECODER_TELL_STATUS_OK;
}


static FLAC__StreamDecoderLengthStatus length_callback(
   const FLAC__StreamDecoder *decoder,
   FLAC__uint64 *stream_length, void *dptr)
{
   FLACFILE *ff = (FLACFILE *)dptr;
   ALLEGRO_FILE *fh = ff->fh;
   (void)decoder;
   
   /* XXX check error */
   *stream_length = (FLAC__uint64)al_fsize(fh);

   return FLAC__STREAM_DECODER_LENGTH_STATUS_OK;
}


static FLAC__bool eof_callback(const FLAC__StreamDecoder *decoder, void *dptr)
{
   FLACFILE *ff = (FLACFILE *)dptr;
   ALLEGRO_FILE *fh = ff->fh;
   (void)decoder;

   if (al_feof(fh))
      return true;

   return false;
}


static void metadata_callback(const FLAC__StreamDecoder *decoder,
    const FLAC__StreamMetadata *metadata, void *client_data)
{
   FLACFILE *out = (FLACFILE *)client_data;

   (void)decoder;

   if (metadata->type == FLAC__METADATA_TYPE_STREAMINFO) {
      out->total_samples = metadata->data.stream_info.total_samples;
      out->sample_rate = metadata->data.stream_info.sample_rate;
      out->channels = metadata->data.stream_info.channels;
      out->sample_size = metadata->data.stream_info.bits_per_sample / 8;
   }
}


static void error_callback(const FLAC__StreamDecoder *decoder,
    FLAC__StreamDecoderErrorStatus status, void *client_data)
{
   (void)decoder;
   (void)client_data;

#ifdef ALLEGRO_CFG_ACODEC_FLAC_DLL
   (void)status;
   ALLEGRO_ERROR("Got FLAC error callback\n"); /* lazy */
#else
   ALLEGRO_ERROR("Got FLAC error callback: %s\n",
      FLAC__StreamDecoderErrorStatusString[status]);
#endif
}


static FLAC__StreamDecoderWriteStatus write_callback(
   const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame,
   const FLAC__int32 * const buffer[], void *client_data)
{
   FLACFILE *ff = (FLACFILE *) client_data;
   long len = frame->header.blocksize;
   long bytes = len * ff->channels * ff->sample_size;
   FLAC__uint8 *buf8;
   FLAC__int16 *buf16;
   float *buf32;
   int sample_index;
   int channel_index;
   int out_index;

   if (ff->buffer_pos + bytes > ff->buffer_size) {
      ff->buffer = al_realloc(ff->buffer, ff->buffer_pos + bytes);
      ff->buffer_size = ff->buffer_pos + bytes;
   }

   /* FLAC returns FLAC__int32 and I need to convert it to my own format. */
   buf8 = (FLAC__uint8 *) (ff->buffer + ff->buffer_pos);
   buf16 = (FLAC__int16 *) buf8;
   buf32 = (float *) buf8;

   (void)decoder;
   (void)client_data;

   /* Flatten the array */
   /* TODO: test this array flattening process on 5.1 and higher flac files */
   out_index = 0;
   switch (ff->sample_size) {
      case 1:
         for (sample_index = 0; sample_index < len; sample_index++) {
             for (channel_index = 0;
                  channel_index < ff->channels;
                  channel_index++) {
                buf8[out_index++] =
                   (FLAC__uint8) buffer[channel_index][sample_index];
             }
         }
         break;

      case 2:
         for (sample_index = 0; sample_index < len; sample_index++) {
             for (channel_index = 0; channel_index < ff->channels;
                   channel_index++) {
                buf16[out_index++] =
                   (FLAC__int16) buffer[channel_index][sample_index];
             }
         }
         break;

      case 3:
         for (sample_index = 0; sample_index < len; sample_index++) {
             for (channel_index = 0; channel_index < ff->channels;
                channel_index++)
             {
                /* Little endian */
                /* FIXME: does this work? I only have 16-bit sound card mixer
                 * garbages for other 24-bit codecs too.
                 */
                buf8[out_index++] = (FLAC__uint8) (buffer[channel_index][sample_index] & 0xFF);
                buf8[out_index++] = (FLAC__uint8) ((buffer[channel_index][sample_index] & 0xFF00) >> 8);
                buf8[out_index++] = (FLAC__uint8) ((buffer[channel_index][sample_index] & 0xFF0000) >> 16);
             }
         }
         break;

      case 4:
         for (sample_index = 0; sample_index < len; sample_index++) {
             for (channel_index = 0; channel_index < ff->channels;
                   channel_index++) {
                buf32[out_index++] =
                   (float) buffer[channel_index][sample_index];
             }
         }
         break;

      default:
         /* Word_size not supported. */
         return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
   }

   ff->decoded_samples += len;
   ff->buffer_pos += bytes;
   return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
}

static void flac_close(FLACFILE *ff)
{
   lib.FLAC__stream_decoder_finish(ff->decoder);
   lib.FLAC__stream_decoder_delete(ff->decoder);
   /* Don't close ff->fh here. */
   al_free(ff);
}

/* In seconds. */
static double flac_stream_get_position(ALLEGRO_AUDIO_STREAM *stream)
{
   FLACFILE *ff = (FLACFILE *)stream->extra;
   return ff->streamed_samples / ff->sample_rate;
}


/*
 *  Updates 'stream' with the next chunk of data.
 *  Returns the actual number of bytes written.
 */
static size_t flac_stream_update(ALLEGRO_AUDIO_STREAM *stream, void *data,
   size_t buf_size)
{
   int bytes_per_sample;
   uint64_t wanted_samples;
   uint64_t read_samples;
   size_t written_bytes = 0;
   size_t read_bytes;
   FLACFILE *ff = (FLACFILE *)stream->extra;

   bytes_per_sample = ff->sample_size * ff->channels;
   wanted_samples = buf_size / bytes_per_sample;

   if (ff->streamed_samples + wanted_samples > ff->loop_end) {
      if (ff->loop_end > ff->streamed_samples)
         wanted_samples = ff->loop_end - ff->streamed_samples;
      else
         return 0;
   }

   while (wanted_samples > 0) {
      read_samples = ff->decoded_samples - ff->streamed_samples;

      /* If the buffer size is small, we shouldn't read a new frame or our
       * buffer keeps growing - so only refill when needed.
       */
      if (!read_samples) {
         if (!lib.FLAC__stream_decoder_process_single(ff->decoder))
            break;
         read_samples = ff->decoded_samples - ff->streamed_samples;
         if (!read_samples) {
            break;
         }
      }

      if (read_samples > wanted_samples)
         read_samples = wanted_samples;
      ff->streamed_samples += read_samples;
      wanted_samples -= read_samples;
      read_bytes = read_samples * bytes_per_sample;
      /* Copy data from the FLAC file buffer to the stream buffer. */
      memcpy((uint8_t *)data + written_bytes, ff->buffer, read_bytes);
      /* Make room in the FLACFILE buffer. */
      memmove(ff->buffer, ff->buffer + read_bytes,
         ff->buffer_pos - read_bytes);
      ff->buffer_pos -= read_bytes;
      written_bytes += read_bytes;
   }

   return written_bytes;
}

/* Called from al_destroy_audio_stream. */
static void flac_stream_close(ALLEGRO_AUDIO_STREAM *stream)
{
   FLACFILE *ff = stream->extra;
   _al_acodec_stop_feed_thread(stream);

   al_fclose(ff->fh);
   flac_close(ff);
}

static bool real_seek(ALLEGRO_AUDIO_STREAM *stream, uint64_t sample)
{
   FLACFILE *ff = stream->extra;

   /* We use ff->streamed_samples as the exact sample position for looping and
    * returning the position. Therefore we also use it as reference position
    * when seeking - that is, we call flush below to make the FLAC decoder
    * discard any additional samples it may have buffered already.
    * */
   lib.FLAC__stream_decoder_flush(ff->decoder);
   lib.FLAC__stream_decoder_seek_absolute(ff->decoder, sample);

   ff->buffer_pos = 0;
   ff->streamed_samples = sample;
   ff->decoded_samples = sample;
   return true;
}

static bool flac_stream_seek(ALLEGRO_AUDIO_STREAM *stream, double time)
{
   FLACFILE *ff = stream->extra;
   uint64_t sample = time * ff->sample_rate;
   return real_seek(stream, sample);
}

static bool flac_stream_rewind(ALLEGRO_AUDIO_STREAM *stream)
{
   FLACFILE *ff = stream->extra;
   return real_seek(stream, ff->loop_start);
}

static double flac_stream_get_length(ALLEGRO_AUDIO_STREAM *stream)
{
   FLACFILE *ff = stream->extra;
   return ff->total_samples / ff->sample_rate;
}

static bool flac_stream_set_loop(ALLEGRO_AUDIO_STREAM *stream, double start,
   double end)
{
   FLACFILE *ff = stream->extra;
   ff->loop_start = start * ff->sample_rate;
   ff->loop_end = end * ff->sample_rate;
   return true;
}

static FLACFILE *flac_open(ALLEGRO_FILE* f)
{
   FLACFILE *ff;
   FLAC__StreamDecoderInitStatus init_status;

   if (!init_dynlib()) {
      return NULL;
   }

   ff = al_calloc(1, sizeof *ff);

   ff->decoder = lib.FLAC__stream_decoder_new();
   if (!ff->decoder) {
      ALLEGRO_ERROR("Error allocating FLAC decoder\n");
      goto error;
   }

   ff->fh = f;
   if (!ff->fh) {
      ALLEGRO_ERROR("Error opening FLAC file\n");
      goto error;
   }

   init_status = lib.FLAC__stream_decoder_init_stream(ff->decoder, read_callback,
      seek_callback, tell_callback, length_callback, eof_callback,
      write_callback, metadata_callback, error_callback, ff);
   if (init_status != FLAC__STREAM_DECODER_INIT_STATUS_OK) {
#ifdef ALLEGRO_CFG_ACODEC_FLAC_DLL
      ALLEGRO_ERROR("Error initializing FLAC decoder\n"); /* lazy */
#else
      ALLEGRO_ERROR("Error initializing FLAC decoder: %s\n",
         FLAC__StreamDecoderInitStatusString[init_status]);
#endif
      goto error;
   }

   lib.FLAC__stream_decoder_process_until_end_of_metadata(ff->decoder);

   if (ff->sample_size == 0) {
      ALLEGRO_ERROR("Error: don't support sub 8-bit sizes\n");
      goto error;
   }

   ALLEGRO_INFO("Loaded FLAC sample with properties:\n");
   ALLEGRO_INFO("    channels %d\n", ff->channels);
   ALLEGRO_INFO("    sample_size %d\n", ff->sample_size);
   ALLEGRO_INFO("    rate %.f\n", ff->sample_rate);
   ALLEGRO_INFO("    total_samples %ld\n", (long) ff->total_samples);

   return ff;

error:
   if (ff) {
      if (ff->decoder)
         lib.FLAC__stream_decoder_delete(ff->decoder);
      al_free(ff);
   }
   return NULL;
}

ALLEGRO_SAMPLE *_al_load_flac(const char *filename)
{
   ALLEGRO_FILE *f;
   ALLEGRO_SAMPLE *spl;
   ASSERT(filename);

   f = al_fopen(filename, "rb");
   if (!f)
      return NULL;

   spl = _al_load_flac_f(f);

   al_fclose(f);

   return spl;
}

ALLEGRO_SAMPLE *_al_load_flac_f(ALLEGRO_FILE *f)
{
   ALLEGRO_SAMPLE *sample;
   FLACFILE *ff;

   ff = flac_open(f);
   if (!ff) {
      return NULL;
   }

   ff->buffer_size = ff->total_samples * ff->channels * ff->sample_size;
   ff->buffer = al_malloc(ff->buffer_size);

   lib.FLAC__stream_decoder_process_until_end_of_stream(ff->decoder);

   sample = al_create_sample(ff->buffer, ff->total_samples, ff->sample_rate,
      _al_word_size_to_depth_conf(ff->sample_size),
      _al_count_to_channel_conf(ff->channels), true);

   if (!sample) {
      al_free(ff->buffer);
   }

   flac_close(ff);

   return sample;
}

ALLEGRO_AUDIO_STREAM *_al_load_flac_audio_stream(const char *filename,
   size_t buffer_count, unsigned int samples)
{
   ALLEGRO_FILE *f;
   ALLEGRO_AUDIO_STREAM *stream;
   ASSERT(filename);

   f = al_fopen(filename, "rb");
   if (!f)
      return NULL;

   stream = _al_load_flac_audio_stream_f(f, buffer_count, samples);
   if (!stream) {
      al_fclose(f);
   }

   return stream;
}

ALLEGRO_AUDIO_STREAM *_al_load_flac_audio_stream_f(ALLEGRO_FILE* f,
   size_t buffer_count, unsigned int samples)
{
   ALLEGRO_AUDIO_STREAM *stream;
   FLACFILE *ff;

   ff = flac_open(f);
   if (!ff) {
      return NULL;
   }

   stream = al_create_audio_stream(buffer_count, samples, ff->sample_rate,
      _al_word_size_to_depth_conf(ff->sample_size),
      _al_count_to_channel_conf(ff->channels));

   if (stream) {
      stream->extra = ff;
      ff->loop_start = 0;
      ff->loop_end = ff->total_samples;
      stream->feed_thread = al_create_thread(_al_kcm_feed_stream, stream);
      stream->feeder = flac_stream_update;
      stream->unload_feeder = flac_stream_close;
      stream->rewind_feeder = flac_stream_rewind;
      stream->seek_feeder = flac_stream_seek;
      stream->get_feeder_position = flac_stream_get_position;
      stream->get_feeder_length = flac_stream_get_length;
      stream->set_feeder_loop = flac_stream_set_loop;
      al_start_thread(stream->feed_thread);
   }
   else {
      al_fclose(ff->fh);
      flac_close(ff);
   }

   return stream;
}


/* vim: set sts=3 sw=3 et: */
helper.c/       0           0     0     644     576       `
#include "allegro5/allegro.h"
#include "allegro5/allegro_audio.h"
#include "allegro5/internal/aintern.h"
#include "allegro5/internal/aintern_audio.h"
#include "allegro5/internal/aintern_system.h"
#include "helper.h"

void _al_acodec_stop_feed_thread(ALLEGRO_AUDIO_STREAM *stream)
{
   ALLEGRO_EVENT quit_event;

   quit_event.type = _KCM_STREAM_FEEDER_QUIT_EVENT_TYPE;
   al_emit_user_event(al_get_audio_stream_event_source(stream), &quit_event, NULL);
   al_join_thread(stream->feed_thread, NULL);
   al_destroy_thread(stream->feed_thread);

   stream->feed_thread = NULL;
}
modaudio.c/     0           0     0     644     11366     `
/*
 * Allegro MOD reader
 * author: Matthew Leverton
 */


#include "allegro5/allegro.h"
#include "allegro5/allegro_acodec.h"
#include "allegro5/allegro_audio.h"
#include "allegro5/internal/aintern_audio.h"
#include "allegro5/internal/aintern_exitfunc.h"
#include "allegro5/internal/aintern_system.h"
#include "acodec.h"
#include "helper.h"

#ifndef ALLEGRO_CFG_ACODEC_MODAUDIO
   #error configuration problem, ALLEGRO_CFG_ACODEC_MODAUDIO not set
#endif

#include <dumb.h>
#include <stdio.h>

ALLEGRO_DEBUG_CHANNEL("acodec")


/* forward declarations */
static size_t modaudio_stream_update(ALLEGRO_AUDIO_STREAM *stream, void *data,
   size_t buf_size);
static bool modaudio_stream_rewind(ALLEGRO_AUDIO_STREAM *stream);
static bool modaudio_stream_seek(ALLEGRO_AUDIO_STREAM *stream, double time);
static double modaudio_stream_get_position(ALLEGRO_AUDIO_STREAM *stream);
static double modaudio_stream_get_length(ALLEGRO_AUDIO_STREAM *stream);
static bool modaudio_stream_set_loop(ALLEGRO_AUDIO_STREAM *stream,
   double start, double end);
static void modaudio_stream_close(ALLEGRO_AUDIO_STREAM *stream);


typedef struct MOD_FILE
{
   DUH *duh;
   DUH_SIGRENDERER *sig;
   ALLEGRO_FILE *fh;
   double length;
   long loop_start, loop_end;
} MOD_FILE;


static bool libdumb_loaded = false;


/* dynamic loading support (Windows only currently) */
#ifdef ALLEGRO_CFG_ACODEC_DUMB_DLL
static void *dumb_dll = NULL;
#endif

static struct
{
   long (*duh_render)(DUH_SIGRENDERER *, int, int, float, float, long, void *);
   long (*duh_sigrenderer_get_position)(DUH_SIGRENDERER *);
   void (*duh_end_sigrenderer)(DUH_SIGRENDERER *);
   void (*unload_duh)(DUH *);
   DUH_SIGRENDERER *(*duh_start_sigrenderer)(DUH *, int, int, long);
   DUMBFILE *(*dumbfile_open_ex)(void *, DUMBFILE_SYSTEM *);
   long (*duh_get_length)(DUH *);
   void (*dumb_exit)(void);
   void (*register_dumbfile_system)(DUMBFILE_SYSTEM *);
   DUH *(*dumb_read_it)(DUMBFILE *);
   DUH *(*dumb_read_xm)(DUMBFILE *);
   DUH *(*dumb_read_s3m)(DUMBFILE *);
   DUH *(*dumb_read_mod)(DUMBFILE *);
} lib;


/* Set up DUMB's file system */
static DUMBFILE_SYSTEM dfs, dfs_f;

static void *dfs_open(const char *filename)
{
   return al_fopen(filename, "rb");
}

static int dfs_skip(void *f, long n)
{
   return al_fseek(f, n, ALLEGRO_SEEK_CUR) ? 0 : -1;
}

static int dfs_getc(void *f)
{
   return al_fgetc(f);
}

static long dfs_getnc(char *ptr, long n, void *f)
{
   return al_fread(f, ptr, n);
}

static void dfs_close(void *f)
{
   /* Don't actually close f here. */
   (void)f;
}


/* Stream Functions */

static size_t modaudio_stream_update(ALLEGRO_AUDIO_STREAM *stream, void *data,
   size_t buf_size)
{
   MOD_FILE *const df = stream->extra;
   
   /* the mod files are stereo and 16-bit */
   const int sample_size = 4;
   size_t written;
   size_t i;
   
   written = lib.duh_render(df->sig, 16, 0, 1.0, 65536.0 / 44100.0,
      buf_size / sample_size, data) * sample_size;

   /* Fill the remainder with silence */
   for (i = written; i < buf_size; ++i)
      ((int *)data)[i] = 0x8000;
   
   /* Check to see if a loop is set */
   if (df->loop_start != -1 && 
      df->loop_end < lib.duh_sigrenderer_get_position(df->sig)) {
         modaudio_stream_seek(stream, df->loop_start / 65536.0);
   }   
   
   return written;
}

static void modaudio_stream_close(ALLEGRO_AUDIO_STREAM *stream)
{
   MOD_FILE *const df = stream->extra;
   _al_acodec_stop_feed_thread(stream);
      
   lib.duh_end_sigrenderer(df->sig);
   lib.unload_duh(df->duh);
   if (df->fh)
      al_fclose(df->fh);
}

static bool modaudio_stream_rewind(ALLEGRO_AUDIO_STREAM *stream)
{
   MOD_FILE *const df = stream->extra;
   lib.duh_end_sigrenderer(df->sig);
   df->sig = lib.duh_start_sigrenderer(df->duh, 0, 2, 0);
   return true;
}

static bool modaudio_stream_seek(ALLEGRO_AUDIO_STREAM *stream, double time)
{
   MOD_FILE *const df = stream->extra;
   
   lib.duh_end_sigrenderer(df->sig);
   df->sig = lib.duh_start_sigrenderer(df->duh, 0, 2, time * 65536);
   
   return false;
}

static double modaudio_stream_get_position(ALLEGRO_AUDIO_STREAM *stream)
{
   MOD_FILE *const df = stream->extra;
   return lib.duh_sigrenderer_get_position(df->sig) / 65536.0;
}

static double modaudio_stream_get_length(ALLEGRO_AUDIO_STREAM *stream)
{
   MOD_FILE *const df = stream->extra;
   return df->length;
}

static bool modaudio_stream_set_loop(ALLEGRO_AUDIO_STREAM *stream,
   double start, double end)
{
   MOD_FILE *const df = stream->extra;
   
   df->loop_start = start * 65536;
   df->loop_end = end * 65536;
   
   return true;
}

/* Create the Allegro stream */

static ALLEGRO_AUDIO_STREAM *mod_stream_init(ALLEGRO_FILE* f,
   size_t buffer_count, unsigned int samples, DUH *(loader)(DUMBFILE *))
{
   ALLEGRO_AUDIO_STREAM *stream;
   DUMBFILE *df;
   DUH_SIGRENDERER *sig = NULL;
   DUH *duh = NULL;
   int64_t start_pos = -1;
   
   df = lib.dumbfile_open_ex(f, &dfs_f);
   if (!df)
      return NULL;
      
   start_pos = al_ftell(f);

   duh = loader(df);
   if (!duh) {
      goto Error;
   }

   sig = lib.duh_start_sigrenderer(duh, 0, 2, 0);
   if (!sig) {
      goto Error;
   }

   stream = al_create_audio_stream(buffer_count, samples, 44100,
      ALLEGRO_AUDIO_DEPTH_INT16, ALLEGRO_CHANNEL_CONF_2); 

   if (stream) {
      MOD_FILE *mf = al_malloc(sizeof(MOD_FILE));
      mf->duh = duh;
      mf->sig = sig;
      mf->fh = NULL;
      mf->length = lib.duh_get_length(duh) / 65536.0;
      if (mf->length < 0)
         mf->length = 0;
      mf->loop_start = -1;
      mf->loop_end = -1;

      stream->extra = mf;
      stream->feed_thread = al_create_thread(_al_kcm_feed_stream, stream);
      stream->feeder = modaudio_stream_update;
      stream->unload_feeder = modaudio_stream_close;
      stream->rewind_feeder = modaudio_stream_rewind;
      stream->seek_feeder = modaudio_stream_seek;
      stream->get_feeder_position = modaudio_stream_get_position;
      stream->get_feeder_length = modaudio_stream_get_length;
      stream->set_feeder_loop = modaudio_stream_set_loop;
      al_start_thread(stream->feed_thread);
   }
   else {
      goto Error;
   }

   return stream;

Error:

   if (sig) {
      lib.duh_end_sigrenderer(sig);
   }

   if (duh) {
      lib.unload_duh(duh);
   }

   /* try to return back to where we started to load */
   if (start_pos != -1)
      al_fseek(f, start_pos, ALLEGRO_SEEK_SET);

   return NULL;
}

static void shutdown_libdumb(void)
{
   if (libdumb_loaded) {
      lib.dumb_exit();
      libdumb_loaded = false;
   }

#ifdef ALLEGRO_CFG_ACODEC_DUMB_DLL
   if (dumb_dll) {
      _al_close_library(dumb_dll);
      dumb_dll = NULL;
   }
#endif
}

static bool init_libdumb(void)
{
   if (libdumb_loaded) {
      return true;
   }

#ifdef ALLEGRO_CFG_ACODEC_DUMB_DLL
   dumb_dll = _al_open_library(ALLEGRO_CFG_ACODEC_DUMB_DLL);
   if (!dumb_dll) {
      ALLEGRO_WARN("Could not load " ALLEGRO_CFG_ACODEC_DUMB_DLL "\n");
      return false;
   }

   #define INITSYM(x)                                                         \
      do                                                                      \
      {                                                                       \
         lib.x = _al_import_symbol(dumb_dll, #x);                             \
         if (lib.x == 0) {                                                    \
            ALLEGRO_ERROR("undefined symbol in lib structure: " #x "\n");     \
            return false;                                                     \
         }                                                                    \
      } while(0)
#else
   #define INITSYM(x)   (lib.x = (x))
#endif

   _al_add_exit_func(shutdown_libdumb, "shutdown_libdumb");

   memset(&lib, 0, sizeof(lib));

   INITSYM(duh_render);
   INITSYM(duh_sigrenderer_get_position);
   INITSYM(duh_end_sigrenderer);
   INITSYM(unload_duh);
   INITSYM(duh_start_sigrenderer);
   INITSYM(dumbfile_open_ex);
   INITSYM(duh_get_length);
   INITSYM(dumb_exit);
   INITSYM(register_dumbfile_system);
   INITSYM(dumb_read_it);
   INITSYM(dumb_read_xm);
   INITSYM(dumb_read_s3m);
   INITSYM(dumb_read_mod);

   dfs.open = dfs_open;
   dfs.skip = dfs_skip;
   dfs.getc = dfs_getc;
   dfs.getnc = dfs_getnc;
   dfs.close = dfs_close;
   
   /* Set up DUMB's default I/O to go through Allegro... */
   lib.register_dumbfile_system(&dfs);
   
   /* But we'll actually use them through this version: */
   dfs_f = dfs;
   dfs_f.open = NULL;
   dfs_f.close = NULL;

   libdumb_loaded = true;
   return true;
}

ALLEGRO_AUDIO_STREAM *_al_load_mod_audio_stream(const char *filename,
   size_t buffer_count, unsigned int samples)
{
   ALLEGRO_FILE *f;
   ALLEGRO_AUDIO_STREAM *stream;
   ASSERT(filename);
              
   f = al_fopen(filename, "rb");
   if (!f)
      return NULL;

   stream = _al_load_mod_audio_stream_f(f, buffer_count, samples);

   if (!stream) {
      al_fclose(f);
      return NULL;
   }

   ((MOD_FILE *)stream->extra)->fh = f;
   
   return stream;
}

ALLEGRO_AUDIO_STREAM *_al_load_it_audio_stream(const char *filename,
   size_t buffer_count, unsigned int samples)
{
   ALLEGRO_FILE *f;
   ALLEGRO_AUDIO_STREAM *stream;
   ASSERT(filename);
              
   f = al_fopen(filename, "rb");
   if (!f)
      return NULL;

   stream = _al_load_it_audio_stream_f(f, buffer_count, samples);
   
   if (!stream) {
      al_fclose(f);
      return NULL;
   }

   ((MOD_FILE *)stream->extra)->fh = f;
   
   return stream;
}

ALLEGRO_AUDIO_STREAM *_al_load_xm_audio_stream(const char *filename,
   size_t buffer_count, unsigned int samples)
{
   ALLEGRO_FILE *f;
   ALLEGRO_AUDIO_STREAM *stream;
   ASSERT(filename);
              
   f = al_fopen(filename, "rb");
   if (!f)
      return NULL;

   stream = _al_load_xm_audio_stream_f(f, buffer_count, samples);

   if (!stream) {
      al_fclose(f);
      return NULL;
   }

   ((MOD_FILE *)stream->extra)->fh = f;
   
   return stream;
}

ALLEGRO_AUDIO_STREAM *_al_load_s3m_audio_stream(const char *filename,
   size_t buffer_count, unsigned int samples)
{
   ALLEGRO_FILE *f;
   ALLEGRO_AUDIO_STREAM *stream;
   ASSERT(filename);
              
   f = al_fopen(filename, "rb");
   if (!f)
      return NULL;

   stream = _al_load_s3m_audio_stream_f(f, buffer_count, samples);
   
   if (!stream) {
      al_fclose(f);
      return NULL;
   }
      
   ((MOD_FILE *)stream->extra)->fh = f;
   
   return stream;
}

ALLEGRO_AUDIO_STREAM *_al_load_mod_audio_stream_f(ALLEGRO_FILE *f,
   size_t buffer_count, unsigned int samples)
{
   if (!init_libdumb())
      return NULL;

   return mod_stream_init(f, buffer_count, samples, lib.dumb_read_mod);
}

ALLEGRO_AUDIO_STREAM *_al_load_it_audio_stream_f(ALLEGRO_FILE *f,
   size_t buffer_count, unsigned int samples)
{
   if (!init_libdumb())
      return NULL;

   return mod_stream_init(f, buffer_count, samples, lib.dumb_read_it);
}

ALLEGRO_AUDIO_STREAM *_al_load_xm_audio_stream_f(ALLEGRO_FILE *f,
   size_t buffer_count, unsigned int samples)
{
   if (!init_libdumb())
      return NULL;

   return mod_stream_init(f, buffer_count, samples, lib.dumb_read_xm);
}

ALLEGRO_AUDIO_STREAM *_al_load_s3m_audio_stream_f(ALLEGRO_FILE *f,
   size_t buffer_count, unsigned int samples)
{
   if (!init_libdumb())
      return NULL;

   return mod_stream_init(f, buffer_count, samples, lib.dumb_read_s3m);
}

/* vim: set sts=3 sw=3 et: */
ogg.c/          0           0     0     644     13387     `
/*
 * Allegro5 Ogg Vorbis reader.
 * Can load samples and do streaming
 * author: Ryan Dickie (c) 2008
 */

#include "allegro5/allegro.h"
#include "allegro5/allegro_acodec.h"
#include "allegro5/allegro_audio.h"
#include "allegro5/internal/aintern.h"
#include "allegro5/internal/aintern_audio.h"
#include "allegro5/internal/aintern_system.h"
#include "acodec.h"
#include "helper.h"

#ifndef ALLEGRO_CFG_ACODEC_VORBIS
   #error configuration problem, ALLEGRO_CFG_ACODEC_VORBIS not set
#endif

ALLEGRO_DEBUG_CHANNEL("acodec")

#if defined(ALLEGRO_CFG_ACODEC_TREMOR)
   #include <tremor/ivorbisfile.h>
   #define TREMOR 1
#else
   #include <vorbis/vorbisfile.h>
#endif

typedef struct AL_OV_DATA AL_OV_DATA;

struct AL_OV_DATA {
   OggVorbis_File *vf;
   vorbis_info *vi;
   ALLEGRO_FILE *file;
   int bitstream;
   double loop_start;
   double loop_end;
};


/* dynamic loading support (Windows only currently) */
#ifdef ALLEGRO_CFG_ACODEC_VORBISFILE_DLL
static void *ov_dll = NULL;
static bool ov_virgin = true;
#endif

static struct
{
   int (*ov_clear)(OggVorbis_File *);
   ogg_int64_t (*ov_pcm_total)(OggVorbis_File *, int);
   vorbis_info *(*ov_info)(OggVorbis_File *, int);
#ifndef TREMOR
   int (*ov_open_callbacks)(void *, OggVorbis_File *, const char *, long, ov_callbacks);
   double (*ov_time_total)(OggVorbis_File *, int);
   int (*ov_time_seek_lap)(OggVorbis_File *, double);
   double (*ov_time_tell)(OggVorbis_File *);
   long (*ov_read)(OggVorbis_File *, char *, int, int, int, int, int *);
#else
   int (*ov_open_callbacks)(void *, OggVorbis_File *, const char *, long, ov_callbacks);
   ogg_int64_t (*ov_time_total)(OggVorbis_File *, int);
   int (*ov_time_seek)(OggVorbis_File *, ogg_int64_t);
   ogg_int64_t (*ov_time_tell)(OggVorbis_File *);
   long (*ov_read)(OggVorbis_File *, char *, int, int *);
#endif
} lib;


#ifdef ALLEGRO_CFG_ACODEC_VORBISFILE_DLL
static void shutdown_dynlib(void)
{
   if (ov_dll) {
      _al_close_library(ov_dll);
      ov_dll = NULL;
      ov_virgin = true;
   }
}
#endif


static bool init_dynlib(void)
{
#ifdef ALLEGRO_CFG_ACODEC_VORBISFILE_DLL
   if (ov_dll) {
      return true;
   }

   if (!ov_virgin) {
      return false;
   }

   ov_virgin = false;

   ov_dll = _al_open_library(ALLEGRO_CFG_ACODEC_VORBISFILE_DLL);
   if (!ov_dll) {
      ALLEGRO_WARN("Could not load " ALLEGRO_CFG_ACODEC_VORBISFILE_DLL "\n");
      return false;
   }

   _al_add_exit_func(shutdown_dynlib, "shutdown_dynlib");

   #define INITSYM(x)                                                         \
      do                                                                      \
      {                                                                       \
         lib.x = _al_import_symbol(ov_dll, #x);                               \
         if (lib.x == 0) {                                                    \
            ALLEGRO_ERROR("undefined symbol in lib structure: " #x "\n");     \
            return false;                                                     \
         }                                                                    \
      } while(0)
#else
   #define INITSYM(x)   (lib.x = (x))
#endif

   memset(&lib, 0, sizeof(lib));

   INITSYM(ov_clear);
   INITSYM(ov_open_callbacks);
   INITSYM(ov_pcm_total);
   INITSYM(ov_info);
#ifndef TREMOR
   INITSYM(ov_time_total);
   INITSYM(ov_time_seek_lap);
   INITSYM(ov_time_tell);
   INITSYM(ov_read);
#else
   INITSYM(ov_time_total);
   INITSYM(ov_time_seek);
   INITSYM(ov_time_tell);
   INITSYM(ov_read);
#endif

   return true;

#undef INITSYM
}


static size_t read_callback(void *ptr, size_t size, size_t nmemb, void *dptr)
{
   AL_OV_DATA *ov = (AL_OV_DATA *)dptr;
   size_t ret = 0;

   ret = al_fread(ov->file, ptr, size*nmemb);

   return ret;
}


static int seek_callback(void *dptr, ogg_int64_t offset, int whence)
{
   AL_OV_DATA *ov = (AL_OV_DATA *)dptr;

   switch(whence) {
      case SEEK_SET: whence = ALLEGRO_SEEK_SET; break;
      case SEEK_CUR: whence = ALLEGRO_SEEK_CUR; break;
      case SEEK_END: whence = ALLEGRO_SEEK_END; break;
   }

   if (!al_fseek(ov->file, offset, whence)) {
      return -1;
   }

   return 0;
}


static long tell_callback(void *dptr)
{
   AL_OV_DATA *ov = (AL_OV_DATA *)dptr;
   int64_t ret = 0;

   ret = al_ftell(ov->file);
   if (ret == -1)
      return -1;

   return (long)ret;
}


static int close_callback(void *dptr)
{
   /* Don't close dptr->file here. */
   (void)dptr;
   return 0;
}


static ov_callbacks callbacks = {
   read_callback,
   seek_callback,
   close_callback,
   tell_callback
};


ALLEGRO_SAMPLE *_al_load_ogg_vorbis(const char *filename)
{
   ALLEGRO_FILE *f;
   ALLEGRO_SAMPLE *spl;
   ASSERT(filename);
   
   ALLEGRO_INFO("Loading sample %s.\n", filename);
   f = al_fopen(filename, "rb");
   if (!f) {
      ALLEGRO_WARN("Failed reading %s.\n", filename);
      return NULL;
   }

   spl = _al_load_ogg_vorbis_f(f);

   al_fclose(f);

   return spl;
}


ALLEGRO_SAMPLE *_al_load_ogg_vorbis_f(ALLEGRO_FILE *file)
{
   /* Note: decoding library returns floats.  I always return 16-bit (most
    * commonly supported).
    */
#ifdef ALLEGRO_LITTLE_ENDIAN
   const int endian = 0; /* 0 for Little-Endian, 1 for Big-Endian */
#else
   const int endian = 1; /* 0 for Little-Endian, 1 for Big-Endian */
#endif
   int word_size = 2; /* 1 = 8bit, 2 = 16-bit. nothing else */
   int signedness = 1; /* 0  for unsigned, 1 for signed */
   const int packet_size = 4096; /* suggestion for size to read at a time */
   OggVorbis_File vf;
   vorbis_info* vi;
   char *buffer;
   long pos;
   ALLEGRO_SAMPLE *sample;
   int channels;
   long rate;
   long total_samples;
   int bitstream;
   long total_size;
   AL_OV_DATA ov;
   long read;

   if (!init_dynlib()) {
      return NULL;
   }

   ov.file = file;
   if (lib.ov_open_callbacks(&ov, &vf, NULL, 0, callbacks) < 0) {
      ALLEGRO_WARN("Audio file does not appear to be an Ogg bitstream.\n");
      return NULL;
   }

   vi = lib.ov_info(&vf, -1);

   channels = vi->channels;
   rate = vi->rate;
   total_samples = lib.ov_pcm_total(&vf, -1);
   bitstream = -1;
   total_size = total_samples * channels * word_size;

   ALLEGRO_DEBUG("channels %d\n", channels);
   ALLEGRO_DEBUG("word_size %d\n", word_size);
   ALLEGRO_DEBUG("rate %ld\n", rate);
   ALLEGRO_DEBUG("total_samples %ld\n", total_samples);
   ALLEGRO_DEBUG("total_size %ld\n", total_size);

   buffer = al_malloc(total_size);
   if (!buffer) {
      return NULL;
   }

   pos = 0;
   while (pos < total_size) {
      const int read_size = _ALLEGRO_MIN(packet_size, total_size - pos);
      ASSERT(pos + read_size <= total_size);

      /* XXX error handling */
#ifndef TREMOR
      read = lib.ov_read(&vf, buffer + pos, read_size, endian, word_size,
         signedness, &bitstream);
#else
      (void)endian;
      (void)signedness;
      read = lib.ov_read(&vf, buffer + pos, read_size, &bitstream);
#endif
      pos += read;
      if (read == 0)
         break;
   }

   lib.ov_clear(&vf);

   sample = al_create_sample(buffer, total_samples, rate,
      _al_word_size_to_depth_conf(word_size),
      _al_count_to_channel_conf(channels), true);

   if (!sample) {
      al_free(buffer);
   }

   return sample;
}


static bool ogg_stream_seek(ALLEGRO_AUDIO_STREAM *stream, double time)
{
   AL_OV_DATA *extra = (AL_OV_DATA *) stream->extra;
   if (time >= extra->loop_end)
      return false;
#ifndef TREMOR
   return (lib.ov_time_seek_lap(extra->vf, time) != -1);
#else
   return lib.ov_time_seek(extra->vf, time*1000) != -1;
#endif
}


static bool ogg_stream_rewind(ALLEGRO_AUDIO_STREAM *stream)
{
   AL_OV_DATA *extra = (AL_OV_DATA *) stream->extra;
   return ogg_stream_seek(stream, extra->loop_start);
}


static double ogg_stream_get_position(ALLEGRO_AUDIO_STREAM *stream)
{
   AL_OV_DATA *extra = (AL_OV_DATA *) stream->extra;
#ifndef TREMOR
   return lib.ov_time_tell(extra->vf);
#else
   return lib.ov_time_tell(extra->vf)/1000.0;
#endif
}


static double ogg_stream_get_length(ALLEGRO_AUDIO_STREAM *stream)
{
   AL_OV_DATA *extra = (AL_OV_DATA *) stream->extra;
#ifndef TREMOR
   double ret = lib.ov_time_total(extra->vf, -1);
#else
   double ret = lib.ov_time_total(extra->vf, -1)/1000.0;
#endif
   return ret;
}


static bool ogg_stream_set_loop(ALLEGRO_AUDIO_STREAM *stream, double start, double end)
{
   AL_OV_DATA *extra = (AL_OV_DATA *) stream->extra;

   extra->loop_start = start;
   extra->loop_end = end;
   
   return true;
}


/* To be called when stream is destroyed */
static void ogg_stream_close(ALLEGRO_AUDIO_STREAM *stream)
{
   AL_OV_DATA *extra = (AL_OV_DATA *) stream->extra;

   _al_acodec_stop_feed_thread(stream);

   al_fclose(extra->file);

   lib.ov_clear(extra->vf);
   al_free(extra->vf);
   al_free(extra);
   stream->extra = NULL;
}


static size_t ogg_stream_update(ALLEGRO_AUDIO_STREAM *stream, void *data,
                                size_t buf_size)
{
   AL_OV_DATA *extra = (AL_OV_DATA *) stream->extra;
	
#ifdef ALLEGRO_LITTLE_ENDIAN
   const int endian = 0;      /* 0 for Little-Endian, 1 for Big-Endian */
#else
   const int endian = 1;      /* 0 for Little-Endian, 1 for Big-Endian */
#endif
   const int word_size = 2;   /* 1 = 8bit, 2 = 16-bit. nothing else */
   const int signedness = 1;  /* 0 for unsigned, 1 for signed */

   unsigned long pos = 0;
   int read_length = buf_size;
#ifndef TREMOR
   double ctime = lib.ov_time_tell(extra->vf);
#else
   double ctime = lib.ov_time_tell(extra->vf)/1000.0;
#endif
   double rate = extra->vi->rate;
   double btime = ((double)buf_size / ((double)word_size * (double)extra->vi->channels)) / rate;
   unsigned long read;
   
   if (stream->spl.loop == _ALLEGRO_PLAYMODE_STREAM_ONEDIR) {
      if (ctime + btime > extra->loop_end) {
         read_length = (extra->loop_end - ctime) * rate * (double)word_size * (double)extra->vi->channels;
         if (read_length < 0)
            return 0;
         read_length += read_length % word_size;
      }
   }
   while (pos < (unsigned long)read_length) {
#ifndef TREMOR
      read = lib.ov_read(extra->vf, (char *)data + pos,
         read_length - pos, endian, word_size, signedness, &extra->bitstream);
#else
      (void)endian;
      (void)signedness;
      read = lib.ov_read(extra->vf, (char *)data + pos,
         read_length - pos, &extra->bitstream);
#endif
      pos += read;
	   
      /* If nothing read then now to silence from here to the end. */
      if (read == 0) {
         int silence = _al_kcm_get_silence(stream->spl.spl_data.depth);
         memset((char *)data + pos, silence, buf_size - pos);
         /* return the number of usefull byes written */
         return pos;
      }
   }

   return pos;
}


ALLEGRO_AUDIO_STREAM *_al_load_ogg_vorbis_audio_stream(const char *filename,
   size_t buffer_count, unsigned int samples)
{
   ALLEGRO_FILE *f;
   ALLEGRO_AUDIO_STREAM *stream;
   ASSERT(filename);

   ALLEGRO_INFO("Loading stream %s.\n", filename);
   f = al_fopen(filename, "rb");
   if (!f) {
      ALLEGRO_WARN("Failed reading %s.\n", filename);
      return NULL;
   }

   stream = _al_load_ogg_vorbis_audio_stream_f(f, buffer_count, samples);
   if (!stream) {
      al_fclose(f);
   }

   return stream;
}


ALLEGRO_AUDIO_STREAM *_al_load_ogg_vorbis_audio_stream_f(ALLEGRO_FILE *file,
   size_t buffer_count, unsigned int samples)
{
   const int word_size = 2; /* 1 = 8bit, 2 = 16-bit. nothing else */
   OggVorbis_File* vf;
   vorbis_info* vi;
   int channels;
   long rate;
   long total_samples;
   long total_size;
   AL_OV_DATA* extra;
   ALLEGRO_AUDIO_STREAM* stream;

   if (!init_dynlib()) {
      return NULL;
   }

   extra = al_malloc(sizeof(AL_OV_DATA));
   if (extra == NULL) {
      ALLEGRO_ERROR("Failed to allocate AL_OV_DATA struct.\n");
      return NULL;
   }

   extra->file = file;
   
   vf = al_malloc(sizeof(OggVorbis_File));
   if (lib.ov_open_callbacks(extra, vf, NULL, 0, callbacks) < 0) {
      ALLEGRO_WARN("ogg: Input does not appear to be an Ogg bitstream.\n");
      return NULL;
   }

   extra->vf = vf;

   vi = lib.ov_info(vf, -1);
   channels = vi->channels;
   rate = vi->rate;
   total_samples = lib.ov_pcm_total(vf, -1);
   total_size = total_samples * channels * word_size;

   extra->vi = vi;

   extra->bitstream = -1;

   ALLEGRO_DEBUG("channels %d\n", channels);
   ALLEGRO_DEBUG("word_size %d\n", word_size);
   ALLEGRO_DEBUG("rate %ld\n", rate);
   ALLEGRO_DEBUG("total_samples %ld\n", total_samples);
   ALLEGRO_DEBUG("total_size %ld\n", total_size);
	
   stream = al_create_audio_stream(buffer_count, samples, rate,
            _al_word_size_to_depth_conf(word_size),
            _al_count_to_channel_conf(channels));
   if (!stream) {
      lib.ov_clear(vf);
      al_free(vf);
      return NULL;
   }

   stream->extra = extra;

   extra->loop_start = 0.0;
   extra->loop_end = ogg_stream_get_length(stream);
   stream->feed_thread = al_create_thread(_al_kcm_feed_stream, stream);
   stream->quit_feed_thread = false;
   stream->feeder = ogg_stream_update;
   stream->rewind_feeder = ogg_stream_rewind;
   stream->seek_feeder = ogg_stream_seek;
   stream->get_feeder_position = ogg_stream_get_position;
   stream->get_feeder_length = ogg_stream_get_length;
   stream->set_feeder_loop = ogg_stream_set_loop;
   stream->unload_feeder = ogg_stream_close;
   al_start_thread(stream->feed_thread);
	
   return stream;
}


/* vim: set sts=3 sw=3 et: */

wav.c/          0           0     0     644     12673     `
/*
 * Allegro5 WAV reader
 * author: Matthew Leverton 
 */

#include <stdio.h>

#include "allegro5/allegro_audio.h"
#include "allegro5/internal/aintern_audio.h"
#include "acodec.h"
#include "helper.h"

ALLEGRO_DEBUG_CHANNEL("wav")


typedef struct WAVFILE
{
   ALLEGRO_FILE *f; 
   size_t dpos;     /* the starting position of the data chunk */
   int freq;        /* e.g., 44100 */
   short bits;      /* 8 (unsigned char) or 16 (signed short) */
   short channels;  /* 1 (mono) or 2 (stereo) */
   int sample_size; /* channels * bits/8 */
   int samples;     /* # of samples. size = samples * sample_size */
   double loop_start;
   double loop_end;
} WAVFILE;


/* wav_open:
 *  Opens f and prepares a WAVFILE struct with the WAV format info.
 *  On a successful return, the ALLEGRO_FILE is at the beginning of the sample data.
 *  returns the WAVFILE on success, or NULL on failure.
 */
static WAVFILE *wav_open(ALLEGRO_FILE *f)
{
   WAVFILE *wavfile = NULL;
   char buffer[12];

   if (!f)
      goto wav_open_error;

   /* prepare default values */
   wavfile = al_malloc(sizeof(WAVFILE));
   if (!wavfile) {
      return NULL;
   }
   wavfile->f = f;
   wavfile->freq = 22050;
   wavfile->bits = 8;
   wavfile->channels = 1;

   /* check the header */
   if (al_fread(f, buffer, 12) != 12)
      goto wav_open_error;

   if (memcmp(buffer, "RIFF", 4) || memcmp(buffer+8, "WAVE", 4))
      goto wav_open_error;
   
   /* Read as many leading fmt chunks as exist, then read until a data chunk
    * is found.
    */
   while (true) {
      int length = 0;
      short pcm = 0;

      if (al_fread(f, buffer, 4) != 4)
         goto wav_open_error;

      /* check to see if it's a fmt chunk */
      if (!memcmp(buffer, "fmt ", 4)) {

         length = al_fread32le(f);
         if (length < 16)
            goto wav_open_error;

         /* should be 1 for PCM data */
         pcm = al_fread16le(f);
         if (pcm != 1)
            goto wav_open_error;

         /* mono or stereo data */
         wavfile->channels = al_fread16le(f);

         if ((wavfile->channels != 1) && (wavfile->channels != 2))
            goto wav_open_error;

         /* sample frequency */
         wavfile->freq = al_fread32le(f);
       
         /* skip six bytes */
         al_fseek(f, 6, ALLEGRO_SEEK_CUR);   

         /* 8 or 16 bit data? */
         wavfile->bits = al_fread16le(f);
         if ((wavfile->bits != 8) && (wavfile->bits != 16))
            goto wav_open_error;

         /* Skip remainder of chunk */
         length -= 16;
         if (length > 0)
            al_fseek(f, length, ALLEGRO_SEEK_CUR);
      }
      else {
         if (!memcmp(buffer, "data", 4))
            break;
         ALLEGRO_INFO("Ignoring chunk: %c%c%c%c\n", buffer[0], buffer[1],
            buffer[2], buffer[3]);
         length = al_fread32le(f);
         al_fseek(f, length, ALLEGRO_SEEK_CUR);
      }
   }

   /* find out how many samples exist */
   wavfile->samples = al_fread32le(f);

   if (wavfile->channels == 2) {
      wavfile->samples = (wavfile->samples + 1) / 2;
   }

   if (wavfile->bits == 16) {
      wavfile->samples /= 2;
   }

   wavfile->sample_size = wavfile->channels * wavfile->bits / 8;

   wavfile->dpos = al_ftell(f);

   return wavfile;

wav_open_error:

   if (wavfile)
      al_free(wavfile);

   return NULL;
}

/* wav_read:
 *  Reads up to 'samples' number of samples from the wav ALLEGRO_FILE into 'data'.
 *  Returns the actual number of samples written to 'data'.
 */
static size_t wav_read(WAVFILE *wavfile, void *data, size_t samples)
{
   size_t bytes_read;

   ASSERT(wavfile);

   bytes_read = al_fread(wavfile->f, data, samples * wavfile->sample_size);

   /* PCM data in RIFF WAV files is little endian.
    * PCM data in RIFX WAV files is big endian (which we don't support).
    */
#ifdef ALLEGRO_BIG_ENDIAN
   if (wavfile->bits == 16) {
      uint8_t *p = data;
      const uint8_t *const end = p + bytes_read - 1; /* in case bytes_read is not even */

      /* swap high/low bytes */
      while (p < end) {
         uint8_t *const q = p + 1;
         const uint8_t tmp = *p;
         *p = *q;
         *q = tmp;
         p = q;       
      }
   }
#endif

   return bytes_read / wavfile->sample_size;
}


/* wav_close:
 *  Closes the ALLEGRO_FILE and frees the WAVFILE struct.
 */
static void wav_close(WAVFILE *wavfile)
{
   ASSERT(wavfile);

   al_free(wavfile);
}


static bool wav_stream_seek(ALLEGRO_AUDIO_STREAM * stream, double time)
{
   WAVFILE *wavfile = (WAVFILE *) stream->extra;
   int align = (wavfile->bits / 8) * wavfile->channels;
   unsigned long cpos = time * (double)(wavfile->freq * (wavfile->bits / 8) * wavfile->channels);
   if (time >= wavfile->loop_end)
      return false;
   cpos += cpos % align;
   return (al_fseek(wavfile->f, wavfile->dpos + cpos, ALLEGRO_SEEK_SET) != -1);
}


/* wav_stream_rewind:
 *  Rewinds 'stream' to the beginning of the data chunk.
 *  Returns true on success, false on failure.
 */
static bool wav_stream_rewind(ALLEGRO_AUDIO_STREAM *stream)
{
   WAVFILE *wavfile = (WAVFILE *) stream->extra;
   return wav_stream_seek(stream, wavfile->loop_start);
}


static double wav_stream_get_position(ALLEGRO_AUDIO_STREAM * stream)
{
   WAVFILE *wavfile = (WAVFILE *) stream->extra;
   double samples_per = (double)((wavfile->bits / 8) * wavfile->channels) * (double)(wavfile->freq);
   return ((double)(al_ftell(wavfile->f) - wavfile->dpos) / samples_per);
}


static double wav_stream_get_length(ALLEGRO_AUDIO_STREAM * stream)
{
   WAVFILE *wavfile = (WAVFILE *) stream->extra;
   double total_time = (double)(wavfile->samples) / (double)(wavfile->freq);
   return total_time;
}


static bool wav_stream_set_loop(ALLEGRO_AUDIO_STREAM * stream, double start, double end)
{
   WAVFILE *wavfile = (WAVFILE *) stream->extra;
   wavfile->loop_start = start;
   wavfile->loop_end = end;
   return true;
}


/* wav_stream_update:
 *  Updates 'stream' with the next chunk of data.
 *  Returns the actual number of bytes written.
 */
static size_t wav_stream_update(ALLEGRO_AUDIO_STREAM *stream, void *data,
   size_t buf_size)
{
   int bytes_per_sample, samples, samples_read;
   double ctime, btime;

   WAVFILE *wavfile = (WAVFILE *) stream->extra;
   bytes_per_sample = (wavfile->bits / 8) * wavfile->channels;
   ctime = wav_stream_get_position(stream);
   btime = ((double)buf_size / (double)bytes_per_sample) / (double)(wavfile->freq);
   
   if (stream->spl.loop == _ALLEGRO_PLAYMODE_STREAM_ONEDIR && ctime + btime > wavfile->loop_end) {
      samples = ((wavfile->loop_end - ctime) * (double)(wavfile->freq));
   }
   else {
      samples = buf_size / bytes_per_sample;
   }
   if (samples < 0)
      return 0;

   samples_read = wav_read(wavfile, data, samples);

   return samples_read * bytes_per_sample;
}


/* wav_stream_close:
 *  Closes the 'stream'.
 */
static void wav_stream_close(ALLEGRO_AUDIO_STREAM *stream)
{
   WAVFILE *wavfile = (WAVFILE *) stream->extra;

   _al_acodec_stop_feed_thread(stream);
   
   al_fclose(wavfile->f);
   wav_close(wavfile);
   stream->extra = NULL;
   stream->feed_thread = NULL;
}


/* _al_load_wav:
 *  Reads a RIFF WAV format sample ALLEGRO_FILE, returning an ALLEGRO_SAMPLE
 *  structure, or NULL on error.
 */
ALLEGRO_SAMPLE *_al_load_wav(const char *filename)
{
   ALLEGRO_FILE *f;
   ALLEGRO_SAMPLE *spl;
   ASSERT(filename);

   f = al_fopen(filename, "rb");
   if (!f)
      return NULL;

   spl = _al_load_wav_f(f);

   al_fclose(f);

   return spl;
}

ALLEGRO_SAMPLE *_al_load_wav_f(ALLEGRO_FILE *fp)
{
   WAVFILE *wavfile = wav_open(fp);
   ALLEGRO_SAMPLE *spl = NULL;

   if (wavfile) {
      size_t n = (wavfile->bits / 8) * wavfile->channels * wavfile->samples;
      char *data = al_malloc(n);

      if (data) {
         spl = al_create_sample(data, wavfile->samples, wavfile->freq,
            _al_word_size_to_depth_conf(wavfile->bits / 8),
            _al_count_to_channel_conf(wavfile->channels), true);

         if (spl) {
            memset(data, 0, n);
            wav_read(wavfile, data, wavfile->samples);
         }
         else {
            al_free(data);
         }
      }
      wav_close(wavfile);
   }

   return spl;
}


/* _al_load_wav_audio_stream:
*/
ALLEGRO_AUDIO_STREAM *_al_load_wav_audio_stream(const char *filename,
   size_t buffer_count, unsigned int samples)
{
   ALLEGRO_FILE *f;
   ALLEGRO_AUDIO_STREAM *stream;
   ASSERT(filename);

   f = al_fopen(filename, "rb");
   if (!f)
      return NULL;

   stream = _al_load_wav_audio_stream_f(f, buffer_count, samples);
   if (!stream) {
      al_fclose(f);
   }

   return stream;
}

/* _al_load_wav_audio_stream_f:
*/
ALLEGRO_AUDIO_STREAM *_al_load_wav_audio_stream_f(ALLEGRO_FILE* f,
   size_t buffer_count, unsigned int samples)
{
   WAVFILE* wavfile;
   ALLEGRO_AUDIO_STREAM* stream;

   wavfile = wav_open(f);
   
   if (wavfile == NULL)
      return NULL;

   stream = al_create_audio_stream(buffer_count, samples, wavfile->freq,
      _al_word_size_to_depth_conf(wavfile->bits / 8),
      _al_count_to_channel_conf(wavfile->channels));

   if (stream) {
      stream->extra = wavfile;
      wavfile->loop_start = 0.0;
      wavfile->loop_end = wav_stream_get_length(stream);
      stream->feed_thread = al_create_thread(_al_kcm_feed_stream, stream);
      stream->feeder = wav_stream_update;
      stream->unload_feeder = wav_stream_close;
      stream->rewind_feeder = wav_stream_rewind;
      stream->seek_feeder = wav_stream_seek;
      stream->get_feeder_position = wav_stream_get_position;
      stream->get_feeder_length = wav_stream_get_length;
      stream->set_feeder_loop = wav_stream_set_loop;
      al_start_thread(stream->feed_thread);
   }
   else {
      wav_close(wavfile);
   }

   return stream;
}


/* _al_save_wav:
 * Writes a sample into a wav ALLEGRO_FILE.
 * Returns true on success, false on error.
 */
bool _al_save_wav(const char *filename, ALLEGRO_SAMPLE *spl)
{
   ALLEGRO_FILE *pf = al_fopen(filename, "wb");

   if (pf) {
      bool rv = _al_save_wav_f(pf, spl);
      al_fclose(pf);
      return rv;
   }

   return false;   
}


/* _al_save_wav_f:
 * Writes a sample into a wav packfile.
 * Returns true on success, false on error.
 */
bool _al_save_wav_f(ALLEGRO_FILE *pf, ALLEGRO_SAMPLE *spl)
{
   size_t channels, bits;
   size_t data_size;
   size_t samples;
   size_t i, n;

   ASSERT(spl);
   ASSERT(pf);

   /* XXX: makes use of ALLEGRO_SAMPLE internals */

   channels = (spl->chan_conf >> 4) + (spl->chan_conf & 0xF);
   bits = (spl->depth == ALLEGRO_AUDIO_DEPTH_INT8 ||
           spl->depth == ALLEGRO_AUDIO_DEPTH_UINT8) ? 8 : 16;

   if (channels < 1 || channels > 2)
      return false;

   samples = spl->len;
   data_size = samples * channels * bits / 8;
   n = samples * channels;

   al_fputs(pf, "RIFF");
   al_fwrite32le(pf, 36 + data_size);
   al_fputs(pf, "WAVE");

   al_fputs(pf, "fmt ");
   al_fwrite32le(pf, 16);
   al_fwrite16le(pf, 1);
   al_fwrite16le(pf, channels);
   al_fwrite32le(pf, spl->frequency);
   al_fwrite32le(pf, spl->frequency * channels * bits / 8);
   al_fwrite16le(pf, channels * bits / 8);
   al_fwrite16le(pf, bits);

   al_fputs(pf, "data");
   al_fwrite32le(pf, data_size);


   if (spl->depth == ALLEGRO_AUDIO_DEPTH_UINT8) {
      al_fwrite(pf, spl->buffer.u8, samples * channels);
   }
   else if (spl->depth == ALLEGRO_AUDIO_DEPTH_INT16) {
      al_fwrite(pf, spl->buffer.s16, samples * channels * 2);
   }
   else if (spl->depth == ALLEGRO_AUDIO_DEPTH_INT8) {
      int8_t *data = spl->buffer.s8;
      for (i = 0; i < samples; ++i) {
         al_fputc(pf, *data++ + 0x80);
      }
   }
   else if (spl->depth == ALLEGRO_AUDIO_DEPTH_UINT16) {
      uint16_t *data = spl->buffer.u16;
      for (i = 0; i < n; ++i) {
         al_fwrite16le(pf, *data++ - 0x8000);
      }
   }
   else if (spl->depth == ALLEGRO_AUDIO_DEPTH_INT24) {
      int32_t *data = spl->buffer.s24;
      for (i = 0; i < n; ++i) {
         const int v = ((float)(*data++ + 0x800000) / 0x7FFFFF) * 0x7FFF - 0x8000;
         al_fwrite16le(pf, v);
      }
   }
   else if (spl->depth == ALLEGRO_AUDIO_DEPTH_UINT24) {
      uint32_t *data = spl->buffer.u24;
      for (i = 0; i < n; ++i) {
         const int v = ((float)(*data++) / 0x7FFFFF) * 0x7FFF - 0x8000;
         al_fwrite16le(pf, v);
      }
   }
   else if (spl->depth == ALLEGRO_AUDIO_DEPTH_FLOAT32) {
      float *data = spl->buffer.f32;
      for (i = 0; i < n; ++i) {
         al_fwrite16le(pf, *data * 0x7FFF);
         data++;
      }
   }
   else {
      ALLEGRO_ERROR("Unknown audio depth (%d) when saving wav ALLEGRO_FILE.\n",
         spl->depth);
      return false;
   }

   return true;
}

/* vim: set sts=3 sw=3 et: */

